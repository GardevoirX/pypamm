#!/usr/bin/python
from numpy import *
import scipy.sparse.csgraph as csg
import sys, os, argparse, time

parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,description=""" 
  ****************************************** 
  *                                        * 
  *               PAMM Tools               * 
  *                                        * 
  ****************************************** 
                                               
  cluster merging based on:                  
    - bootstrap                
    - log-sum-exp (not implemented)
                                            
  Version: 1.0                               
  Date   : 08/11/17                          
  Author : robert.meissner@epfl.ch 
""")   
parser.add_argument("D", type=int, help="dimensionality")
parser.add_argument("grid", type=str, help="reference grid file")
parser.add_argument("bootstrap", type=str, help="bootstrap file")
parser.add_argument("-t", "--thresh", type=float, default=0.9, help="threshold to merge cluster. (default=0.9)")
parser.add_argument("-m", "--mode", type=str, default='flood', help="merging mode. iterative (iter) or flooding (flood) (default=flood)")
parser.add_argument("--nolog", help="do not use log probabilities.", action="store_false")

parser.add_argument("-v", "--verbose", help="increase output verbosity.", action="store_true")

######### MAIN #########
def main():
  args = parser.parse_args()
  starttime = time.time()

  try:
    with open(args.grid) as file:
        pass
  except IOError as e:
    print "ERROR: Unable to open grid file"
  try:
    with open(args.bootstrap) as file:
        pass
  except IOError as e:
      print "ERROR: Unable to open bootstrap file"
  
  grid = loadtxt(args.grid)
  clus = array(grid[:,args.D],dtype=int)  
  prob = grid[:,args.D+1]
  boot = loadtxt(args.bootstrap,dtype=int)   
  
  # total number of grid points
  N = len(grid)
  # total number of cluster
  Nc = len(unique(clus))
   
  # run adjacency calculation
  adj,ic = adjacency(prob,clus,boot)
  
  # merging step
  if args.mode=='flood':  macro = merge(adj,ic,args.thresh,N)
  elif args.mode=='iter': 
    while True:
      # merge to highest adjacent cluster
      macro = merge(adj,ic,args.thresh,N,'iter')
      # total number of new macrocluster
      Ntmp = len(unique(macro))
      # break if we reached convergence and no new macrocluster is found
      if Nc == Ntmp: break
      # reset total number of cluster
      Nc = Ntmp
      # run adjacency calculation again
      adj,ic = adjacency(prob,macro,boot)

  savetxt('macro',array([macro+1,clus]).T,fmt='%d')
  
  savetxt('adj',adj,fmt="%f")  
      
  if args.verbose: sys.stderr.write("Finished in %.2f seconds.\n"%(time.time()-starttime))
  return 0
####### END MAIN ########

def adjacency(prob,clus,boot):
  uc = unique(clus)
  Nc = len(uc)
  Nb = len(boot)

  # calculate reference Qs
  lc = []
  Qi = zeros(Nc)
  for i,c in enumerate(uc):
    ic = where(clus == c)[0]
    Qi[i] = exp(prob[ic]).sum()
    lc.append(ic)
  
  # calculate overlap Qs
  QAi = zeros((Nb,boot.flatten().max(),Nc))
  for i in xrange(Nb):
      for j,c in enumerate(unique(boot[i,:])):
          ic = where(boot[i,:] == c)[0]
          for k in xrange(Nc):
              itmp = intersect1d(ic, lc[k])
              QAi[i,j,k] = exp(prob[itmp]).sum() 
  
  aij = zeros((Nc,Nc))
  for i in xrange(Nc):
      for j in xrange(i+1):
          tij = 0
          for bs in xrange(Nb):
              for k in xrange(boot[bs,:].max()):
                  tij += QAi[bs,k,i] * QAi[bs,k,j]
          aij[i,j] = aij[j,i] = tij/(Qi[i]*Qi[j]*Nb) 
          
  return (aij,lc)

def merge(adj,ic,thresh,N,mode='flood'):
  Nc = len(adj)
 
  imacro = ones(N,dtype=int)*-1
 
  if mode=='flood':
    cij = adj > thresh
    cgraph=csg.csgraph_from_dense(cij, null_value=False)
    cc=csg.connected_components(cgraph) 

    for i in xrange(cc[0]):
        for j in xrange(Nc):
            if cc[1][j] == i:
                imacro[ic[j]] = i
                
  elif mode=='iter':
    # set the diagonal elements to -inf
    fill_diagonal(adj,-inf)
    # create boolean adjacency matrix
    cij = zeros([Nc,Nc],dtype=bool)
    for i in range(Nc):
      # is there an adjacent cluster
      if sum(adj[i,:]) == 0: continue
      # connect to cluster with highest adjacency
      j = argmax(adj[i,:])
      
      if adj[i,j] > thresh: 
        cij[i,j] = True
        cij[j,i] = True
    # get macrocluster ids and reset number of clusters
    _, macro = csg.connected_components(cij)
    
    for i,idxs in enumerate(ic):
      imacro[idxs] = macro[i]
  return imacro

if __name__ == "__main__":
    sys.exit(main())
    
#verbose = False  # no verbosity
#saveadj = False  # don't store adjacency
#savegrd = False  # don't store macrogrid
#savebrd = False  # don't store boarder points
#savegrp = False  # don't store gabriel graph
#grpfile = []     # don't read gabriel graph
#errflag = False  # don't use errors
#logflag = True   # logarithm of probabilities as input
#thresh  = 0.9    # threshold to merge cluster
#D       = -1     # dimensionality needs to be specified

#if len(sys.argv) < 2:
#  print "usage: merge -D dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-gread graph] [-gsave] [-v] [-h] grid"
#  sys.exit("ERROR: no grid file specified")
#else:
#  for i,s in enumerate(sys.argv):
#    if   s == '-D'     : D       = int(sys.argv[i+1])
#    elif s == '-t'     : thresh  = float(sys.argv[i+1])
#    elif s == '-err'   : errflag = True
#    elif s == '-log'   : logflag = False
#    elif s == '-adj'   : saveadj = True
#    elif s == '-m'     : savegrd = True
#    elif s == '-b'     : savebrd = True
#    elif s == '-gsave' : savegrp = True
#    elif s == '-gread' : grpfile = sys.argv[i+1]
#    elif s == '-v'     : verbose = True
#    elif s == '-h'     : 
#      print """
#usage: merge -D dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-gread graph] [-gsave] [-v] [-h] grid"

# required:
# 
#   -D dim        : dimensionality
#   grid          : pamm grid file
#       
# optional:

#   -t thresh     : threshold to merge cluster                   [0.9]
#   -err          : use error of KDE in adjacency                [false]
#   -log          : use logarithm of probabilities               [true]
#   -adj          : write out adjacency matrix                   [false]
#   -m            : write out gridfile containing                [false]
#                   new macrogrid              
#   -b            : write out boarder points                     [false]
#   -gread graph  : read gapriel graph from file                 []
#   -gsave        : write out gapriel graph connecting points    [false]
#   -v            : turn verbosity on                            [false]
#   -h            : show this message
#      """
#      sys.exit()

#print """ 
# ****************************************** 
# *                                        * 
# *               PAMM Tools               * 
# *                                        * 
# ****************************************** 
#                                               
# cluster merging based on:                  
#   - gabriel neighbors                      
#   - adjacency criterion based 
#     on treshold or kde error
#   - true log-sum-exp                       
#                                            
# Version: 1.0                               
# Date   : 08/11/17                          
# Author : robert.meissner@epfl.ch                                                           
#"""   

########################################################################
####                                                                 ###
####                          input control                          ###
####                                                                 ###
########################################################################

#if D < 0: sys.exit("ERROR: no dimension specified")

#try:
#    with open(sys.argv[-1]) as file:
#        pass
#except IOError as e:
#    print "ERROR: Unable to open grid file"
#gridfile = sys.argv[-1]

#if grpfile:
#  try:
#      with open(grpfile) as file:
#          pass
#  except IOError as e:
#      print "ERROR: Unable to open neigh file"

## define output names
#if gridfile[-5:] == '.grid': basename = os.path.basename(gridfile[:-5])
#else : basename = os.path.basename(gridfile)
#mgridfile = basename + '.mgrid'
#macrofile = basename + '.macro'
#adjfile   = basename + '.adj'
#brdfile   = basename + '.boarders'

## load data
#data = loadtxt(gridfile)

#X    = data[:,:D]
#cid  = array(map(int,data[:,D]))
#oid  = cid*1
#prob = data[:,D+1]

#N  = X.shape[0]
#Nc = len(unique(cid))
#uc = unique(cid)

## output every this many steps if looped over cluster
#multi = round(log10(Nc))-1
#if multi < 1: multi = 0
#csteps = 10**multi

## output every this many steps if looped over grid
#multi = round(log10(N))-1
#if multi < 1: multi = 0
## multiplier whenever something over a grid is calculated
#steps = 10**multi

## prepare adjacency matrix skeleton
#if logflag: 
#  thresh = log(thresh)
#  adj = ones([Nc,Nc])*-inf
#else:
#  adj = zeros([Nc,Nc])


########################################################################
####                                                                 ###
####                          main program                           ###
####                                                                 ###
########################################################################

#neighs = zeros([N,N], dtype=bool)
#if grpfile:
#  if verbose: print " Loading Gabriel graph"
#  with open(grpfile) as gf:
#      i = 0
#      for line in gf:
#          if '#' in line: continue
#          line = line.replace('F','0')
#          line = line.replace('T','1')
#          neighs[i,:] = array(map(int,line.split()),dtype=bool)
#          if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)
#          i = i+1
#else:
#  grpfile = basename + '.neigh'
#  if verbose: print " Compute distance matrix"
#  # we need squared distances for gabriel graph
#  distsq = zeros([N,N])
#  for i,xi in enumerate(X):
#      # matrix is symmetric, loop over upper triangular
#      distsq[i,:] = linalg.norm(xi-X,axis=1)**2
#      # distance to myself is far away
#      distsq[i,i] = inf
#      if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)
#  if verbose: print " Building Gabriel graph"
#  neighs = zeros([N,N], dtype=bool)
#  # find gabriel neighbors of i
#  for i in range(N):
#      # matrix is symmetric, loop over upper triangular
#      for j in range(i):        
#          # if i and j are in the same cluster or 
#          # j has lower probability than i skip operation
#          if (cid[i] == cid[j]): continue
#          flag = distsq[i,j] > (distsq[i,:] + distsq[j,:])
#          if not flag.any():     
#            neighs[i,j] = True
#      if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)
#  
#if savebrd: 
#  if verbose: print " Marking border points"
#  # create array to store border points
#  brd = zeros(N,dtype=bool)
#  # loop over all cluster
#  for i in range(N):
#    for j in range(N):
#        # are i and j in two different clusters?
#        if cid[i] == cid[j]: continue
#        # cluster ci and cj are connected if points i and j are gabriel neighbors
#        if neighs[i,j]:
#            # mark points as boarder points
#            brd[i] = True
#            brd[j] = True
#    
#if verbose: print " Building adjacency matrix"

## loop over all cluster
#for i in range(N):
#    # max prob of cluster ci
#    maxPci = max(prob[cid==cid[i]])
#    for j in range(N):
#        # are i and j in two different clusters?
#        if cid[i] == cid[j]: continue
#        
#        # cluster ci and cj are connected if points i and j are gabriel neighbors
#        if neighs[i,j]:
#        
#            # max prob of cluster cj
#            maxPcj = max(prob[cid==cid[j]])
#            
#            # store highest adjacency between cluster 
#            if logflag:
#                # use micheles log-approximation for sums
#                if prob[i] > prob[j]: avgP = prob[i] + log(1.+exp(prob[j]-prob[i]))
#                else:                 avgP = prob[j] + log(1.+exp(prob[i]-prob[j]))
#                tmp = avgP - min(maxPci,maxPcj) - log(2)
#                
#                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
#            else:
#                # straightforward adjacency without log-exp-prob
#                tmp = (prob[i]+prob[j])/(2.*min(maxPci,maxPcj))
#                
#                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
#              
#    if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)


## rescale adjacency matrix to identify connected nodes
#if verbose: print " Finding macrocluster"

#iteration = 0
#while True:
#  # create boolean adjacency matrix
#  adj_bool = zeros([Nc,Nc],dtype=bool)
#  # store previous number of cluster
#  Ntmp = Nc*1
#  for i in range(Nc):
#    # is there an adjacent cluster
#    if sum(adj[i,:]) == 0: continue
#    # connect to cluster with highest adjacency
#    j = argmax(adj[i,:])
#    if adj[i,j] > thresh: 
#      adj_bool[i,j] = True
#      adj_bool[j,i] = True
#  # get macrocluster ids and reset number of clusters
#  Nc, m = connected_components(adj_bool)
#  
#  # check if we should stop iterations
#  if Ntmp == Nc: break
#  
#  # write out adjacency matrix to file if desired 
#  if saveadj: 
#    if logflag: savetxt(adjfile+'.%d' % iteration,adj,header="adjacency matrix (log-scaled)") 
#    else:       savetxt(adjfile+'.%d' % iteration,adj,header="adjacency matrix")    
#  
#  # write out cluster association to macrocluster
#  f = open(macrofile+'.%d' % iteration,'w')
#  f.write("# cluster macrocluster\n")
#  for i,c in enumerate(uc):
#    f.write("%d %d\n" % (c,m[i]+1))
#  f.close
#  
#  # reset cluster ids according to new macroclusters
#  for i,c in enumerate(cid):
#    cid[i] = m[c-1]+1
#  uc = unique(cid)
#  
#  # write out macrogrid file and boarder points if desired 
#  if savegrd: 
#    fout = open(mgridfile+'.%d' % iteration,'w')
#    with open(gridfile) as fin:
#      i = 0
#      for line in fin:
#        # skip comments
#        if '#' in line: continue
#        # convert cluster from grid to macrocluster and write out
#        data = map(float,line.split()) 
#        data[D] = cid[i]
#        # append flag to identify boarder points if desired
#        if savebrd: 
#          if brd[i]: b = 1
#          else: b = 0
#          data.append(b)
#        i = i+1
#        fout.write(' '.join(map(str,data))+'\n')
#    fout.close()
#  
#  # redo the adjacency matrix for macrocluster
#  if logflag: 
#    adj = ones([Nc,Nc])*-inf
#  else:
#    adj = zeros([Nc,Nc])
#  if verbose: print " Building adjacency matrix"
#  for i in range(N):
#      # max prob of cluster ci
#      maxPci = max(prob[cid==cid[i]])
#      for j in range(N):
#          # are i and j in two different clusters?
#          if cid[i] == cid[j]: continue
#          
#          # cluster ci and cj are connected if points i and j are gabriel neighbors
#          if neighs[i,j]:
#              # max prob of cluster cj
#              maxPcj = max(prob[cid==cid[j]])
#              
#              # store highest adjacency between cluster 
#              if logflag:
#                  # use micheles log-approximation for sums
#                  if prob[i] > prob[j]: avgP = prob[i] + log(1.+exp(prob[j]-prob[i]))
#                  else:                 avgP = prob[j] + log(1.+exp(prob[i]-prob[j]))
#                  tmp = avgP - min(maxPci,maxPcj) - log(2)
#                  
#                  if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
#              else:
#                  # straightforward adjacency without log-exp-prob
#                  tmp = (prob[i]+prob[j])/(2.*min(maxPci,maxPcj))
#                  
#                  if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
#                
#      if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)

#  # increase iteration counter
#  iteration = iteration + 1
# 
########################################################################
####                                                                 ###
####                       output of program                         ###
####                                                                 ###
########################################################################    

#if verbose: print " Write out"

## write gabriel graph to file if desired
#if savegrp: savetxt(grpfile,neighs,fmt='%d')
#    
## write adjacency matrix to file if desired 
#if saveadj: 
#  if logflag: savetxt(adjfile,adj,header="adjacency matrix (log-scaled)") 
#  else:       savetxt(adjfile,adj,header="adjacency matrix")              

## write out macrogrid file and boarder points if desired 
#if savegrd: 
#  fout = open(mgridfile,'w')
#  with open(gridfile) as fin:
#    i = 0
#    for line in fin:
#      # skip comments
#      if '#' in line: continue
#      # convert cluster from grid to macrocluster and write out
#      data = map(float,line.split()) 
#      data[D] = cid[i]
#      # append flag to identify boarder points if desired
#      if savebrd: 
#        if brd[i]: b = 1
#        else: b = 0
#        data.append(b)
#      i = i+1
#      fout.write(' '.join(map(str,data))+'\n')
#  fout.close()
#      
## write out cluster association to macrocluster
#f = open(macrofile,'w')
#f.write("# cluster macrocluster\n")
#for i,c in enumerate(unique(oid)):
#  cnew = unique(cid[oid == c])
#  if len(cnew) > 1: sys.exit("ERROR: something wrong with macroclustering")
#  f.write("%d %d\n" % (c,cnew))
#f.close()
