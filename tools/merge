#!/usr/bin/python
from numpy import *
from scipy.sparse.csgraph import connected_components
from scipy.misc import factorial
import sys

verbose = False  # no verbosity
saveadj = False  # don't store adjacency
savegrd = False  # don't store macrogrid
errflag = False  # don't use errors
logflag = True   # logarithm of probabilities as input
thresh  = 0.9    # threshold to merge cluster
D       = -1     # dimensionality needs to be specified

if len(sys.argv) < 2:
  print "usage: merge -d dim [-t] [-e] [-l] [-adj] [-m] [-v] [-h] grid"
  sys.exit("ERROR: no grid file specified")
else:
  for i,s in enumerate(sys.argv):
    if   s == '-d'   : D       = int(sys.argv[i+1])
    elif s == '-t'   : thresh  = float(sys.argv[i+1])
    elif s == '-e '  : errflag = True
    elif s == '-l'   : logflag = False
    elif s == '-adj' : saveadj = True
    elif s == '-m'   : savegrd = True
    elif s == '-v'   : verbose = True
    elif s == '-h'   : 
      print "usage: merge -d dim [-t] [-v] [-h] grid"
      print " "
      print " -d dim        : dimensionality"
      print " "
      print " -t thresh     : threshold to merge cluster [0.9]"
      print " "
      print " -e            : use error of KDE in adjacency [false]"
      print " "
      print " -l            : use logarithm of probabilities [true]"
      print " "
      print " -adj          : write out adjacency matrix [false]"
      print " "
      print " -m            : write out gridfile containing"
      print "                 new macrogrid [false]"
      print " "
      print " -v            : turn verbosity on [false]"
      print " "
      print " -h            : show this message"
      sys.exit()
#    else:
#      sys.exit("unrecognized input")

print "                                            " 
print " ****************************************** "
print " *                                        * "
print " *               PAMM Tools               * "
print " *                                        * "
print " ****************************************** "
print "                                            "   
print " cluster merging based on:                  "
print "   - adjacency                              "
print "   - errors (not implemented yet)           "
print "   - true log-sum-exp                       "
print "                                            "
print " Version: 1.0                               "
print " Date   : 02/10/17                          "
print " Author : robert.meissner@epfl.ch           "
print "                                            "    
print "                                            "    

#######################################################################
###                                                                 ###
###                          input control                          ###
###                                                                 ###
#######################################################################

if D < 0: sys.exit("ERROR: no dimension specified")

try:
    with open(sys.argv[-1]) as file:
        pass
except IOError as e:
    print "ERROR: Unable to open file"
gridfile = sys.argv[-1]

# define output names
if gridfile[-5:] == '.grid': basename = gridfile[:-5] 
else : basename = gridfile
mgridfile = basename + '.mgrid'
macrofile = basename + '.macro'
adjfile   = basename + '.adj'

# load data
data = loadtxt(gridfile)

X    = data[:,:D]
cid  = array(map(int,data[:,D]))
prob = data[:,D+1]

Nc = len(unique(cid))
uc = unique(cid)

# output every this many steps (estimated automatically)
multi = int(log10(Nc))-1
if multi < 1: multi = 0
steps = 10**multi

#######################################################################
###                                                                 ###
###                          main program                           ###
###                                                                 ###
#######################################################################

if verbose: print " Finding connections between clusters"
connections = zeros([Nc,X.shape[0]],dtype=int)
for ic,c in enumerate(uc):   
    for i,x in enumerate(X):
        # loop over points in my cluster
        if c != cid[i]: continue
        mindist = inf
        jmin = -1
        for j,y in enumerate(X):
            # check if we are in same cluster
            if c == cid[j]: continue
            dist = linalg.norm(x-y) 
            if dist < mindist:
                mindist = dist
                jmin = j
        if jmin > -1: connections[ic,jmin] = 1
    if verbose and (mod(ic+1,steps)==0): print "  %d / %d" % (ic+1,Nc)

if verbose: print " Building adjacency matrix"
adj = zeros([Nc,Nc])
# loop over all connections for each cluster
for i,ci in enumerate(uc):
    for j,cj in enumerate(uc):
        if i==j: continue
        # first get all boarder points from clusters i and j
        ij = (connections[i,:] > 0) & (cid==cj)
        ji = (connections[j,:] > 0) & (cid==ci)
        # check if clusters are adjacent
        if (sum(ij) > 0) & (sum(ji) > 0):
            # find max prob of each cluster
            maxPci = max(prob[cid==ci])
            maxPcj = max(prob[cid==cj])
            # find max prob of boundary points for each cluster     
            maxPi = max(prob[ji])
            maxPj = max(prob[ij])
            # calculate adjacency
            if logflag:
              # use series expansionion of exponential
              # error for k equal 100 is approx. 10**-25
              avgP = 0.
              for k in range(100):
                avgP = avgP + (maxPi**k + maxPj**k) / factorial(k)
              adj[i,j] = exp(log(avgP) - min(maxPci,maxPcj) - log(2))
            else:
              # straightforward adjacency
              adj[i,j] = (maxPi+maxPj)/(2.*min(maxPci,maxPcj))
               
    if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,Nc)

#######################################################################
###                                                                 ###
###                       output of program                         ###
###                                                                 ###
#######################################################################    

if verbose: print " Write out"
    
# write adjacency matrix to file if desired 
if saveadj: savetxt(adjfile,adj)            

# rescale adjacency matrix to identify connected nodes
adj[where(adj <= thresh)] = 0
adj[where(adj >  thresh)] = 1

if verbose: print " Finding macrocluster"
# get macrocluster ids
Nm, m = connected_components(adj)

# write adjacency matrix to file if desired 
if savegrd: 
  fout = open(mgridfile,'w')
  with open(gridfile) as fin:
    for line in fin:
      # skip comments
      if '#' in line: continue
      data = map(float,line.split()) 
      data[D] = m[int(data[D])-1]+1
      fout.write(' '.join(map(str,data))+'\n')
    
# write out cluster association to macrocluster
f = open(macrofile,'w')
f.write("# cluster macrocluster\n")
for i,c in enumerate(uc):
  f.write("%d %d\n" % (c,m[i]+1))
f.close()
